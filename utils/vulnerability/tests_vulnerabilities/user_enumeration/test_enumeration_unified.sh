#!/bin/bash
# ==============================================================================
# Teste de Vulnerabilidade: Enumeração de Utilizadores (Unificado)
# Endpoints: Login, Reset Password, Account Confirmation
# ==============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
RESULTS_FILE="$SCRIPT_DIR/relatorio_privacidade_utilizadores.txt"
> "$RESULTS_FILE"

# Carregar variáveis de ambiente
load_env() {
    local env_file="$1"
    if [ -f "$env_file" ]; then
        while IFS= read -r line || [ -n "$line" ]; do
            line="${line%%#*}"
            line=$(echo "$line" | xargs)
            [[ -z "$line" ]] && continue
            if [[ "$line" =~ ^[A-Za-z_][A-Za-z0-9_]*=.*$ ]]; then
                export "$line"
            fi
        done < "$env_file"
    fi
}

load_env "$SCRIPT_DIR/../../../../.env"

# Configuração de Ambientes
ENV_TYPE="${1:-local}"
VALID_EMAIL="$2"

case "$ENV_TYPE" in
    "local")
        BASE_URL="http://localhost:7000"
        HOST_HEADER="dev.local:7000"
        ;;
    "dev")
        BASE_URL="https://172.31.204.12"
        HOST_HEADER="172.31.204.12"
        ;;
    "tst")
        BASE_URL="https://10.55.37.38"
        HOST_HEADER="10.55.37.38"
        ;;
    "ppr")
        BASE_URL="https://preprod.dados.gov.pt"
        HOST_HEADER="preprod.dados.gov.pt"
        ;;
    "prd")
        BASE_URL="https://www.dados.gov.pt"
        HOST_HEADER="www.dados.gov.pt"
        ;;
    *)
        # Se o primeiro argumento não for um alias conhecido, assumimos que é o email
        # e usamos 'local' como padrão (mantendo compatibilidade anterior)
        VALID_EMAIL="$1"
        BASE_URL="http://localhost:7000"
        HOST_HEADER="dev.local:7000"
        ENV_TYPE="local (default)"
        ;;
esac

log() { echo -e "$1" | tee -a "$RESULTS_FILE"; }

# Função auxiliar para extrair CSRF
get_csrf_token() {
    local url="$1"
    local cookie_file="$2"
    local resp_file=$(mktemp)
    curl -s -L -k -c "$cookie_file" -H "Host: $HOST_HEADER" "$url" > "$resp_file"
    local token=$(grep 'csrf_token' "$resp_file" | sed -n 's/.*value="\([^"]*\)".*/\1/p' | head -1)
    rm "$resp_file"
    echo "$token"
}

# Função principal de teste
test_endpoint() {
    local type="$1" # "login" | "reset" | "confirm"
    local email_valid="$2"
    local email_invalid="nonexistent_$(date +%s)@example.com"
    local url=""
    local data_prefix=""
    
    case $type in
        "login")
            url="${BASE_URL%/}/pt/login/"
            data_prefix="password=WrongPass123&"
            ;;
        "reset")
            url="${BASE_URL%/}/pt/reset/"
            ;;
        "confirm")
            url="${BASE_URL%/}/pt/confirm/"
            ;;
        "register")
            url="${BASE_URL%/}/pt/register/"
            data_prefix="first_name=Test&last_name=User&accept_conditions=on&"
            ;;
    esac

    log "\n[+] A TESTAR ENDPOINT: $url ($type)"
    
    # 1. Testar Email INVÁLIDO
    local cookie_inv=$(mktemp)
    local csrf_inv=$(get_csrf_token "$url" "$cookie_inv")
    if [ -z "$csrf_inv" ]; then log "  [!] Erro ao obter CSRF para teste inválido."; return; fi
    
    local resp_inv_out=$(mktemp)
    local status_inv=$(curl -s -L -k -b "$cookie_inv" -H "Referer: $url" -H "Host: $HOST_HEADER" \
        -d "${data_prefix}email=$email_invalid&csrf_token=$csrf_inv" -X POST -w "%{http_code}" "$url" -o "$resp_inv_out")
    local resp_inv=$(cat "$resp_inv_out")
    rm "$resp_inv_out"
    
    # 2. Testar Email VÁLIDO (se fornecido)
    if [ -n "$email_valid" ]; then
        local cookie_val=$(mktemp)
        local csrf_val=$(get_csrf_token "$url" "$cookie_val")
        local resp_val_out=$(mktemp)
        local status_val=$(curl -s -L -k -b "$cookie_val" -H "Referer: $url" -H "Host: $HOST_HEADER" \
            -d "${data_prefix}email=$email_valid&csrf_token=$csrf_val" -X POST -w "%{http_code}" "$url" -o "$resp_val_out")
        local resp_val=$(cat "$resp_val_out")
        rm "$resp_val_out"

        # Extrair mensagens
        local msg_inv=$(echo "$resp_inv" | grep -o 'fr-error-text[^>]*>[^<]*' | head -1 | sed 's/.*>//' | xargs)
        local msg_val=$(echo "$resp_val" | grep -o 'fr-error-text[^>]*>[^<]*' | head -1 | sed 's/.*>//' | xargs)
        [ -z "$msg_inv" ] && msg_inv="(Sem mensagem de erro visível)"
        [ -z "$msg_val" ] && msg_val="(Sem mensagem de erro visível)"

        log "  - Inexistente: [Msg: $msg_inv] [HTTP: $status_inv]"
        log "  - Existente:   [Msg: $msg_val] [HTTP: $status_val]"

        # Comparação Inteligente: Mensagem e código HTTP
        if [ "$msg_inv" == "$msg_val" ] && [ "$status_inv" == "$status_val" ]; then
            log "  [OK] As mensagens e estados HTTP são IDÊNTICAS."
            log "  [RESULTADO] SEGURO contra enumeração."
        else
            log "  [!] ALERTA: Diferenças detetadas."
            log "  [RESULTADO] VULNERÁVEL ou comportamento inconsistente."
        fi
        rm "$cookie_val"
    else
        log "  [i] Apenas teste de email inexistente realizado. Forneça um email real para comparação."
        # Checar se bloqueado por reCAPTCHA
        if echo "$resp_inv" | grep -q "recaptcha" && echo "$resp_inv" | grep -q "missing"; then
            log "  [!] NOTA: O teste automático foi bloqueado pelo reCAPTCHA."
        fi
    fi
    rm "$cookie_inv"
}

log "============================================================"
log " RELATÓRIO DE VULNERABILIDADE: ENUMERAÇÃO DE UTILIZADORES"
log " Data: $(date)"
log " Alvo: $BASE_URL ($ENV_TYPE)"
log "============================================================"


test_endpoint "login" "$VALID_EMAIL"
test_endpoint "reset" "$VALID_EMAIL"
test_endpoint "confirm" "$VALID_EMAIL"
test_endpoint "register" "$VALID_EMAIL"

log "\n============================================================"
log " FIM DO RELATÓRIO"
log " Resultados em: $RESULTS_FILE"
log "============================================================"
